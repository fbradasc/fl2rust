use crate::utils;
use fluid_parser::ast::*;
use std::sync::atomic;

static COUNTER: atomic::AtomicUsize = atomic::AtomicUsize::new(0);
static I18N: atomic::AtomicBool = atomic::AtomicBool::new(false);

pub const ALLOWS: &str = r#"// Automatically generated by fl2rust

#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(clippy::needless_update)]"#;

const HEADER: &str = r#"
use fltk::browser::*;
use fltk::button::*;
use fltk::dialog::*;
use fltk::enums::*;
use fltk::frame::*;
use fltk::group::*;
use fltk::image::*;
use fltk::input::*;
use fltk::menu::*;
use fltk::misc::*;
use fltk::output::*;
use fltk::prelude::*;
use fltk::table::*;
use fltk::text::*;
use fltk::tree::*;
use fltk::valuator::*;
use fltk::widget::*;
use fltk::window::*;"#;

fn i18nize(s: &str) -> String {
    if I18N.load(atomic::Ordering::Relaxed) {
        format!("tr!(\"{}\")", s)
    } else {
        format!("\"{}\"", s)
    }
}

fn is_parent_type(typ: &str) -> bool {
    matches!(
        typ,
        "Window"
            | "Group"
            | "Pack"
            | "Tabs"
            | "Scroll"
            | "Table"
            | "Tile"
            | "Wizard"
            | "MenuBar"
            | "MenuButton"
            | "Choice"
            | "Flex"
    )
}

fn add_menus(widgets: &[Widget], w: usize) -> String {
    "\tHeret\n".to_string()
}

fn add_widgets(
    parent: Option<&str>,
    widgets: &[Widget],
    named: &mut Vec<(String, String)>,
) -> String {
    let mut wid = String::new();
    let mut flex = String::new();
    for w in 0..widgets.len() {
        let mut name = String::new();
        let typ = utils::de_fl(&widgets[w].typ);
        if typ != "MenuItem" && typ != "Submenu" {
            if let Some(comment) = &widgets[w].props.comment {
                wid += "\t// ";
                wid += comment;
                wid += "\n";
            }
            wid += "\tlet mut ";
            if widgets[w].name.is_empty() {
                let val = COUNTER.load(atomic::Ordering::Relaxed);
                name += "fl2rust_widget_";
                name += &val.to_string();
                COUNTER.store(val + 1, atomic::Ordering::Relaxed);
            } else {
                name += &widgets[w].name;
                named.push((name.clone(), typ.clone()));
            }
            wid += &name;
            wid += " = ";
            wid += &typ;
            wid += "::new(";
            for coord in widgets[w].props.xywh.split_ascii_whitespace() {
                wid += coord;
                wid += ", "
            }
            wid += "None);\n";
            if let Some(label) = &widgets[w].props.label {
                wid += "\t";
                wid += &name;
                wid += ".set_label(";
                wid += &i18nize(&label);
                wid += ");\n";
            }
    
            if is_parent_type(&typ) {
                wid += "\t";
                wid += &name;
                wid += ".end();\n";
            }
    
            if let Some(v) = &widgets[w].props.typ {
                let v = if typ == "Flex" {
                    if v == "HORIZONTAL" {
                        "Row"
                    } else {
                        "Column"
                    }
                } else {
                    v
                };
                wid += &format!(
                    "\t{}.set_type({}Type::{});\n",
                    name,
                    utils::fix_type(&typ),
                    utils::global_to_pascal(v)
                );
            } else if typ == "Flex" {
                wid += &format!("\t{}.set_type(FlexType::Column);\n", name,);
            }
            if let Some(v) = &widgets[w].props.align {
                wid += &format!(
                    "\t{}.set_align(unsafe {{std::mem::transmute({})}});\n",
                    name, v
                );
            }
            if widgets[w].props.resizable.is_some() {
                if parent.is_none() {
                    wid += &format!("\t{}.make_resizable(true);\n", name);
                } else {
                    wid += &format!("\t{}.resizable(&{});\n", parent.unwrap(), name);
                }
            }
            if widgets[w].props.visible.is_some() {
                wid += &format!("\t{}.show();\n", name);
            }
            if widgets[w].props.hide.is_some() {
                wid += &format!("\t{}.hide();\n", name);
            }
            if widgets[w].props.deactivate.is_some() {
                wid += &format!("\t{}.deactivate();\n", name);
            }
            if let Some(v) = &widgets[w].props.color {
                wid += &format!("\t{}.set_color(Color::by_index({}));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.selection_color {
                wid += &format!("\t{}.set_selection_color(Color::by_index({}));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.tooltip {
                wid += &format!("\t{}.set_tooltip({});\n", name, i18nize(v));
            }
            if let Some(v) = &widgets[w].props.image {
                wid += &format!("\t{0}.set_image(Some(SharedImage::load(\"{1}\").expect(\"Could not find image: {1}\")));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.deimage {
                wid += &format!("\t{0}.set_deimage(Some(SharedImage::load(\"{1}\").expect(\"Could not find image: {1}\")));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.r#box {
                let temp = utils::global_to_pascal(v);
                let temp = match temp.as_str() {
                    "OflatBox" => "OFlatFrame",
                    "OshadowBox" => "OShadowBox",
                    "RflatBox" => "RFlatBox",
                    "RshadowBox" => "RShadowBox",
                    _ => temp.as_str(),
                };
                wid += &format!("\t{}.set_frame(FrameType::{});\n", name, temp);
            }
            if let Some(v) = &widgets[w].props.down_box {
                let temp = utils::global_to_pascal(v);
                let temp = match temp.as_str() {
                    "OflatBox" => "OFlatFrame",
                    "OshadowBox" => "OShadowBox",
                    "RflatBox" => "RFlatBox",
                    "RshadowBox" => "RShadowBox",
                    _ => temp.as_str(),
                };
                wid += &format!("\t{}.set_down_frame(FrameType::{});\n", name, temp);
            }
            if let Some(v) = &widgets[w].props.labeltype {
                let temp = utils::global_to_pascal(v);
                let temp = if temp == "No" { "None" } else { temp.as_str() };
                wid += &format!("\t{}.set_label_type(LabelType::{});\n", name, temp);
            }
            if let Some(v) = &widgets[w].props.labelfont {
                wid += &format!("\t{}.set_label_font(Font::by_index({}));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.labelsize {
                wid += &format!("\t{}.set_label_size({});\n", name, v);
            }
            if let Some(v) = &widgets[w].props.labelcolor {
                wid += &format!("\t{}.set_label_color(Color::by_index({}));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.when {
                wid += &format!(
                    "\t{}.set_trigger(unsafe {{std::mem::transmute({})}});\n",
                    name, v
                );
            }
            if let Some(v) = &widgets[w].props.textfont {
                wid += &format!("\t{}.set_text_font(Font::by_index({}));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.textsize {
                wid += &format!("\t{}.set_text_size({});\n", name, v);
            }
            if let Some(v) = &widgets[w].props.textcolor {
                wid += &format!("\t{}.set_text_color(Color::by_index({}));\n", name, v);
            }
            if let Some(v) = &widgets[w].props.shortcut {
                wid += &format!(
                    "\t{}.set_shortcut(unsafe {{std::mem::transmute({})}});\n",
                    name, v
                );
            }
            if let Some(v) = &widgets[w].props.gap {
                wid += &format!("\t{}.set_pad({});\n", name, v);
            }
            if let Some(v) = &widgets[w].props.minimum {
                wid += &format!("\t{}.set_minimum({} as _);\n", name, v);
            }
            if let Some(v) = &widgets[w].props.maximum {
                wid += &format!("\t{}.set_maximum({} as _);\n", name, v);
            }
            if let Some(v) = &widgets[w].props.size {
                wid += &format!("\t{}.set_size({} as _);\n", name, v);
            }
            if let Some(v) = &widgets[w].props.slider_size {
                wid += &format!("\t{}.set_slider_size({} as _);\n", name, v);
            }
            if let Some(v) = &widgets[w].props.step {
                wid += &format!("\t{}.set_step({} as _, 1);\n", name, v);
            }
            if let Some(v) = &widgets[w].props.value {
                let val = if typ.contains("Button") {
                    let b = v
                        .parse::<i32>()
                        .expect("Buttons should have integral values");
                    if b != 0 {
                        "true".to_string()
                    } else {
                        "false".to_string()
                    }
                } else if (typ.contains("Input") || typ.contains("Output")) && !typ.contains("Value") {
                    i18nize(v)
                } else {
                    format!("{} as _", v)
                };
                wid += &format!("\t{}.set_value({});\n", name, val);
            }
            if let Some(v) = &widgets[w].props.code0 {
                wid += "\t";
                wid += v;
                wid += "\n";
            }
            if let Some(v) = &widgets[w].props.code1 {
                wid += "\t";
                wid += v;
                wid += "\n";
            }
            if let Some(v) = &widgets[w].props.code2 {
                wid += "\t";
                wid += v;
                wid += "\n";
            }
            if let Some(v) = &widgets[w].props.code3 {
                wid += "\t";
                wid += v;
                wid += "\n";
            }
            if let Some(v) = &widgets[w].props.extra_code {
                wid += "\t";
                wid += v;
                wid += "\n";
            }
            if let Some(v) = &widgets[w].props.callback {
                if typ != "MenuItem" && typ != "Submenu" {
                    if v.starts_with('{') || v.starts_with("move") || v.starts_with('|') {
                        wid += &format!("\t{}.set_callback({});\n", name, v);
                    } else {
                        wid += &format!(
                            "\t{}.set_callback(move |{}| {{ \n\t    {} \n\t}});\n",
                            name, name, v
                        );
                    };
                }
            }
    
            if let Some(sizes) = &widgets[w].props.size_tuple {
                let count: Vec<_> = sizes.split_ascii_whitespace().collect();
                let count: Vec<_> = count.iter().skip(1).collect();
                for e in count.chunks_exact(2) {
                    let idx: usize = e[0].parse().unwrap();
                    flex += &format!(
                        "\t{0}.set_size(&{0}.child({1}).unwrap(), {2});\n",
                        name, idx, e[1]
                    );
                }
                flex += &format!("\t{}.recalc();\n", name);
            }
            if let Some(parent) = parent {
                wid += "\t";
                wid += parent;
                wid += ".add(&";
                wid += &name;
                wid += ");\n"
            }
    
            if !widgets[w].children.is_empty() {
                let ch = add_widgets(Some(&name), &widgets[w].children, named);
                wid += &ch;
            }
        } else {
            if !widgets[w].children.is_empty() {
                let ch = add_menus(widgets, w);
                wid += &ch;
            }
        }
    }
    wid += &flex;
    wid
}

fn add_funcs(functions: &[Function], free: bool, named: &mut Vec<(String, String)>) -> String {
    let mut func = String::new();
    for c in functions {
        func += "\n    pub fn ";
        func += &c.name;
        if let Some(ret) = &c.props.return_type {
            func += " -> ";
            func += ret;
        } else if !free {
            func += " -> Self";
        }
        func += " {\n";
        if !c.widgets.is_empty() {
            func += &add_widgets(None, &c.widgets, named);
        }
        func += "\tSelf {\n";
        if !named.is_empty() {
            for n in named.iter() {
                func += "\t    ";
                func += &n.0;
                func += ",\n";
            }
        }
        func += "\t}";
        func += "\n    }";
    }
    func
}

/// Generate the output Rust string/file
pub fn generate(ast: &Ast) -> String {
    let mut s = String::new();
    if let Some(i18n) = ast.i18n_type {
        I18N.store(i18n, atomic::Ordering::Relaxed);
    }
    s += "\n";
    let mut classes = vec![];
    let mut funcs = vec![];
    if !ast.decls.is_empty() {
        for decl in &ast.decls {
            s += &decl.decl;
            s += "\n";
        }
    }
    if !ast.comments.is_empty() {
        for comment in &ast.comments {
            s += &comment.comment;
            s += "\n";
        }
    }
    if !ast.functions.is_empty() {
        let mut local_named = vec![];
        let func = add_funcs(&ast.functions, true, &mut local_named);
        funcs.push(func);
    }
    if !ast.classes.is_empty() {
        let mut named: Vec<(String, String)> = vec![];
        let mut class = String::new();
        for c in &ast.classes {
            class += "#[derive(Debug, Clone)]\n";
            class += "pub struct ";
            class += &c.name;
            class += " {\n";
            let fns = add_funcs(&c.functions, false, &mut named);
            if !named.is_empty() {
                for n in &named {
                    class += "    ";
                    class += &n.0;
                    class += ": ";
                    class += &n.1;
                    class += ",\n";
                }
            }
            class += "}\n\n";
            if !c.functions.is_empty() {
                class += "impl ";
                class += &c.name;
                class += " {";
                class += &fns;
                class += "\n}\n\n";
            }
        }
        classes.push(class);
    }
    for f in funcs {
        s += &f;
        s += "\n";
    }
    for c in classes {
        s += &c;
        s += "\n";
    }
    s
}

/// Generate the output Rust string/file
pub fn generate_with_directives_preamble(ast: &Ast) -> String {
    let s = generate(ast);
    format!("{}\n{}\n{}", ALLOWS, HEADER, s)
}
